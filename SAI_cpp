#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <string>
#include "ProcessPattern.h"
#include "GS_QR_fac.h"
#include "backsub.h"
//using namespace std;
double **pattern;
int main() {
    /*Step 1: first thing we want to do is load in the matricies
    do this using a text file with the information for 
    the matricies. 
    Parse from the file to find the nonzero locations as 
    well as the nonzero values
    */
    //FILE *rfile;
    //rfile = fopen("FDnonlinearMat1_1.txt", "r");
    //if(isOpen)
    int n=25;
    double** A;
    /*heres where I want to read the text file and create
    A from the input list of points and their values
    */
    for(int i=0; i<n; i++){
        double rowA[25] = {0};
        //double oldA[25] = A[i];
        //double newA[25]= rowA;
        //*(A[i]) = newA;
        i++;
    }
    //we've made A, now we need to make the sparsity pattern
    //pattern is a global variable here, want to make sure not 
    //mess aroud with that too much
    pattern = processPattern(A);
   /* Step 3: convert for loop into c++ (lines 37-64)
   */
    //initialize that column of all 0s
    int **vecE;
    double **R;
    double **Q;
    double **M;
    double **mk;
    //compute lease squares using QR factorization
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            vecE[j][0]=0;
        }
        vecE[i][0] =1;
        //now we need to convert GS_QR into c++
        GS_QR_fac(A, Q, R);
        double **Qt;
        for(int a=0; a<n; a++){
            for(int b=0; b<n; b++){
                //get the transpose of Q
                Qt[b][a] = Q[a][b];
            }
        }
        double **vecY;
        vecY= matrix_mult(Qt, vecE);
        //mk = backsub(R, y)
        //have to write the C++ file for backsub first!
        mk = backsub(R, vecY);
        //put into a double ** --> record all the calculated columns
        for(int k=0; k<n; k++){
            M[i][k] = mk[k][0];
        }
    }
    cout < "Hello World!";
    return 0;
}